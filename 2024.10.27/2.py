def main():
    num = int(input("Введите число: "))
    
    next_number = num + 1
    previous_number = num - 1
    
    # ИСПРАВИТЬ: вывод не соответствует требуемому формату (лишний символ конца строки, опечатки)
    # ИСПРАВЛЕНИЕ: Так пойдет? P.S. Я намеренно ввел лишний символ конца строки, думал, так лучше.
    output = f"Следущее за числом {num} число: {next_number}\nДля числа {num} предыдущее число: {previous_number}"
    
    print(output)
    
    return num, output, next_number, previous_number

    
if __name__ == "__main__":
    num, output, next_number, previous_number = main()


#======================================
# Это результат в интерактивном режиме
#======================================

# D:\Ilya\Working\Bobkov\2024.10.27>python -i 2.py
# Введите число: 30
# 
# Следущее за числом 30 число: 31
# Для число 30 предыдущее число: 29
# >>> num
# 30
# >>> next_number
# 31
# >>> previous_number
# 29
# >>> print(output)
# 
# Следущее за числом 30 число: 31
# Для число 30 предыдущее число: 29
# >>>


#=============================================
# Я конечно, не имею большого опыта ООП, но когда я хотел сделать задание через перегрузку, оказывается в Python нужно создавать для этого классы, что как по мне неудобно. Этот вариант я сделал для себя, как метод практики с классами.
#=============================================
# КОММЕНТАРИЙ: перегрузка — это переопределение уже существующего метода, что как раз и подразумевает создание производного класса с помощью механики наследования

# КОММЕНТАРИЙ: если вы хотите подробно изучать ООП, то выбрали не тот учебный курс
# ОТВЕТ: Не страшно, я понимаю, но в дальнейшем ООП мне пригодится, и изучать детально я уже буду самостоятельно

# КОММЕНТАРИЙ: создание собственного числового типа с нуля используется весьма редко, в основном мы создаём производный класс от уже существующих классов
# class MyInteger:
#     def __init__(self, value):
#         self.value = value
#     
#     def __add__(self, value):
#         return MyInteger(self.value + 1)
#     
#     def __sub__(self, value):
#         return MyInteger(self.value - 1)
#     
#     def __str__(self):
#         return str(self.value)
# 
# 
# def main():    
#     num = int(input("Введите число: "))
#     my_integer = MyInteger(num)
#     
#     output = (
#         f"\nСледущее за числом {my_integer.value} число: {my_integer + 0}\n"
#         f"Для числа {my_integer.value} предыдущее число: {my_integer - 0}"
#     )
#     print(output)
# 
# 
# if __name__ == "__main__":
#     main()


# КОММЕНТАРИЙ: PEP 8 — сборник рекомендаций по стилистическому оформлению Python кода — их стоит использовать для большего удобства чтения своего и чужого кода: https://peps.python.org/pep-0008/


# ИТОГ: хорошо — 2/2

